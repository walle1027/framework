package org.loed.framework.mybatis.interceptor.impl;

import org.apache.commons.collections.CollectionUtils;
import org.apache.commons.lang3.tuple.Triple;
import org.apache.ibatis.executor.Executor;
import org.apache.ibatis.mapping.MappedStatement;
import org.apache.ibatis.plugin.Intercepts;
import org.apache.ibatis.plugin.Invocation;
import org.apache.ibatis.plugin.Signature;
import org.apache.ibatis.type.JdbcType;
import org.apache.ibatis.type.TypeHandler;
import org.apache.ibatis.type.TypeHandlerRegistry;
import org.loed.framework.common.ServiceLocator;
import org.loed.framework.common.context.SystemContextHolder;
import org.loed.framework.common.orm.Column;
import org.loed.framework.common.orm.Filters;
import org.loed.framework.common.orm.Table;
import org.loed.framework.common.query.QueryBuilder;
import org.loed.framework.common.util.ReflectionUtils;
import org.loed.framework.mybatis.BatchOperationException;
import org.loed.framework.mybatis.BatchType;
import org.loed.framework.mybatis.MybatisSqlBuilder;
import org.loed.framework.mybatis.sharding.ShardingManager;
import org.loed.framework.mybatis.sharding.table.po.IdMapping;

import javax.persistence.GenerationType;
import java.io.Serializable;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.util.*;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.function.Predicate;
import java.util.stream.Collectors;

//import org.loed.framework.common.util.ReflectionUtils;

/***
 * @author wiki
 * todo add metrics
 * todo make type conversion as complete as jdbc
 * @version 1.0.0
 */
@SuppressWarnings("Duplicates")
@Intercepts(
		{
				@Signature(type = Executor.class, method = "update", args = {MappedStatement.class, Object.class}),
		}
)
public class SimpleBatchInterceptor extends BaseBatchInterceptor {

	public SimpleBatchInterceptor() {
	}

	public SimpleBatchInterceptor(int batchSize) {
		super(batchSize);
	}

	@Override
	protected int doBatchInsert(MappedStatement ms, Executor executor, List<Object> poList, Table table) throws SQLException {
		Column idColumn = table.getColumns().stream().filter(Column::isPk).findFirst().orElse(null);
		if (idColumn == null) {
			throw new RuntimeException("entity:" + table.getJavaName() + " has no id column");
		}
		if (table.isSharding()) {
			Map<String, List<Object>> groupedMap = new HashMap<>();
			Set<String> shardingValues = new HashSet<>();
			List<Column> shardingColumns = table.getColumns().stream().filter(Column::isShardingColumn).sorted().collect(Collectors.toList());
			if (CollectionUtils.isEmpty(shardingColumns)) {
				throw new RuntimeException("sharding columns is empty");
			}
			for (Object po : poList) {
				List<String> values = new ArrayList<>();
				shardingColumns.forEach(column -> values.add(String.valueOf(ReflectionUtils.getFieldValue(po, column.getJavaName()))));
				String shardingValue = getShardingValue(values);
				shardingValues.add(shardingValue);
				List<Object> list = groupedMap.computeIfAbsent(shardingValue, k -> new ArrayList<>());
				list.add(po);
			}
			Map<String, String> tableNameMap = getShardingManager().getShardingTableNameByValues(table, shardingValues);

			Map<String, List<String>> reversedMap = new HashMap<>();
			tableNameMap.forEach((k, v) -> {
				reversedMap.computeIfAbsent(v, t -> new ArrayList<>()).add(k);
			});

			int total = 0;
			List<IdMapping> idMappings = new ArrayList<>(poList.size());
			GenerationType idGenerationType = table.getIdGenerationType();
			for (Map.Entry<String, List<String>> entry : reversedMap.entrySet()) {
				String tableName = entry.getKey();
				List<String> values = entry.getValue();
				List<Object> oneTableBatchList = new ArrayList<>();
				if (idGenerationType != GenerationType.AUTO) {
					values.forEach(v -> {
						List<Object> list = groupedMap.get(v);
						for (Object po : list) {
							IdMapping idMapping = new IdMapping();
							idMapping.setShardingTableName(tableName);
							idMapping.setTableName(table.getSqlName());
							idMapping.setShardingValue(v);
							idMapping.setShardingKey(shardingColumns.stream().map(Column::getSqlName).collect(Collectors.joining(",")));
							idMapping.setTableId((Serializable) ReflectionUtils.getFieldValue(po, idColumn.getJavaName()));
							idMappings.add(idMapping);
							oneTableBatchList.add(po);
						}
					});
				}
				total += doOneTableBatchInsert(ms, executor, oneTableBatchList, table, tableName);
				//if id is autogenerated id will get after insert
				if (idGenerationType == GenerationType.AUTO) {
					values.forEach(v -> {
						List<Object> list = groupedMap.get(v);
						for (Object po : list) {
							IdMapping idMapping = new IdMapping();
							idMapping.setShardingTableName(tableName);
							idMapping.setTableName(table.getSqlName());
							idMapping.setShardingValue(v);
							idMapping.setShardingKey(shardingColumns.stream().map(Column::getSqlName).collect(Collectors.joining(",")));
							idMapping.setTableId((Serializable) ReflectionUtils.getFieldValue(po, idColumn.getJavaName()));
							idMappings.add(idMapping);
							oneTableBatchList.add(po);
						}
					});
				}
			}
			//保存Id映射
			getShardingManager().saveIdMappings(idMappings.toArray(new IdMapping[0]));
			return total;
		} else {
			return doOneTableBatchInsert(ms, executor, poList, table, table.getSqlName());
		}
	}

	private int doOneTableBatchInsert(MappedStatement ms, Executor executor, List<Object> poList, Table table, String taleName) throws SQLException {
		StringBuilder builder = new StringBuilder(table.getColumns().size() * 20 + 3);
		String sql = buildInsertSql(taleName, table.getColumns(), builder);

		List<List<Object>> batches = sliceBatch(poList, batchSize);
		int rows = 0;
		long start = System.currentTimeMillis();
		if (logger.isDebugEnabled()) {
			logger.debug("batch insert log: {} start ", sql);
		}
		Connection conn = executor.getTransaction().getConnection();
		for (List<Object> batch : batches) {
			rows = rows + doOneBatchInsert(ms.getConfiguration().getTypeHandlerRegistry(), conn, batch, table, sql);
		}
		if (logger.isDebugEnabled()) {
			logger.debug("batch insert done log, time :{}, rows {}, sql {}, ", System.currentTimeMillis() - start, rows, sql);
		}
		return rows;
	}

	@Override
	protected int doBatchUpdateNonBlank(MappedStatement ms, Executor executor, List<Object> poList, Table table) throws SQLException {
		Column idColumn = table.getColumns().stream().filter(Column::isPk).findFirst().orElse(null);
		if (idColumn == null) {
			throw new RuntimeException("entity class : " + table.getJavaName() + " has no id column");
		}
		if (table.isSharding()) {
			Map<Serializable, Object> objectMap = new HashMap<>();
			Set<Serializable> idSet = new HashSet<>();
			for (Object po : poList) {
				Serializable id = (Serializable) ReflectionUtils.getFieldValue(po, idColumn.getJavaName());
				idSet.add(id);
				objectMap.put(id, po);
			}
			Map<Serializable, String> tableNameMap = getShardingManager().getShardingTableNameByIds(table, idSet);
			if (tableNameMap == null || tableNameMap.isEmpty()) {
				throw new RuntimeException("invalid update list,because it's id hasn't sharding");
			}
			Map<String, List<Serializable>> reversedMap = new HashMap<>();
			tableNameMap.forEach((k, v) -> {
				reversedMap.computeIfAbsent(v, t -> new ArrayList<>()).add(k);
			});
			int total = 0;
			for (Map.Entry<String, List<Serializable>> entry : reversedMap.entrySet()) {
				String tableName = entry.getKey();
				List<Serializable> values = entry.getValue();
				List<Object> oneTableBatchList = values.stream().map(objectMap::get).collect(Collectors.toList());
				total += doOneTableBatchUpdateNonBlank(ms.getConfiguration().getTypeHandlerRegistry(), executor, oneTableBatchList, table, tableName);
			}
			return total;
		} else {
			return doOneTableBatchUpdateNonBlank(ms.getConfiguration().getTypeHandlerRegistry(), executor, poList, table, table.getSqlName());
		}
	}

	@Override
	protected int doBatchUpdateNonNull(MappedStatement ms, Executor executor, List<Object> poList, Table table) throws SQLException {
		Column idColumn = table.getColumns().stream().filter(Column::isPk).findFirst().orElse(null);
		if (idColumn == null) {
			throw new RuntimeException("entity class : " + table.getJavaName() + " has no id column");
		}
		if (table.isSharding()) {
			Map<Serializable, Object> objectMap = new HashMap<>();
			Set<Serializable> idSet = new HashSet<>();
			for (Object po : poList) {
				Serializable id = (Serializable) ReflectionUtils.getFieldValue(po, idColumn.getJavaName());
				idSet.add(id);
				objectMap.put(id, po);
			}
			Map<Serializable, String> tableNameMap = getShardingManager().getShardingTableNameByIds(table, idSet);
			if (tableNameMap == null || tableNameMap.isEmpty()) {
				throw new RuntimeException("invalid update list,because it's id hasn't sharding");
			}
			Map<String, List<Serializable>> reversedMap = new HashMap<>();
			tableNameMap.forEach((k, v) -> {
				reversedMap.computeIfAbsent(v, t -> new ArrayList<>()).add(k);
			});
			int total = 0;
			for (Map.Entry<String, List<Serializable>> entry : reversedMap.entrySet()) {
				String tableName = entry.getKey();
				List<Serializable> values = entry.getValue();
				List<Object> oneTableBatchList = values.stream().map(objectMap::get).collect(Collectors.toList());
				total += doOneTableBatchUpdateNonNull(ms.getConfiguration().getTypeHandlerRegistry(), executor, oneTableBatchList, table, tableName);
			}
			return total;
		} else {
			return doOneTableBatchUpdateNonNull(ms.getConfiguration().getTypeHandlerRegistry(), executor, poList, table, table.getSqlName());
		}
	}

	@Override
	protected int doBatchUpdate(MappedStatement ms, Executor executor, List<Object> poList, Table table, Predicate<Column> predicate) throws SQLException {
		Column idColumn = table.getColumns().stream().filter(Column::isPk).findFirst().orElse(null);
		if (idColumn == null) {
			throw new RuntimeException("entity class : " + table.getJavaName() + " has no id column");
		}
		if (table.isSharding()) {
			Map<Serializable, Object> objectMap = new HashMap<>();
			Set<Serializable> idSet = new HashSet<>();
			for (Object po : poList) {
				Serializable id = (Serializable) ReflectionUtils.getFieldValue(po, idColumn.getJavaName());
				idSet.add(id);
				objectMap.put(id, po);
			}
			Map<Serializable, String> tableNameMap = getShardingManager().getShardingTableNameByIds(table, idSet);
			if (tableNameMap == null || tableNameMap.isEmpty()) {
				throw new RuntimeException("invalid update list,because it's id hasn't sharding");
			}
			Map<String, List<Serializable>> reversedMap = new HashMap<>();
			tableNameMap.forEach((k, v) -> {
				reversedMap.computeIfAbsent(v, t -> new ArrayList<>()).add(k);
			});
			int total = 0;
			for (Map.Entry<String, List<Serializable>> entry : reversedMap.entrySet()) {
				String tableName = entry.getKey();
				List<Serializable> values = entry.getValue();
				List<Object> oneTableBatchList = values.stream().map(objectMap::get).collect(Collectors.toList());
				total += doOneTableUpdate(ms.getConfiguration().getTypeHandlerRegistry(), executor, oneTableBatchList, table, tableName, predicate);
			}
			return total;
		} else {
			return doOneTableUpdate(ms.getConfiguration().getTypeHandlerRegistry(), executor, poList, table, table.getSqlName(), predicate);
		}
	}

	private int doOneTableBatchUpdateNonBlank(TypeHandlerRegistry thr, Executor executor, List<Object> poList, Table table, String tableName) throws SQLException {
		Connection conn = executor.getTransaction().getConnection();
		final StringBuilder builder = new StringBuilder();
		Map<SqlAndParameter, List<Object>> mappedStatement = poList.stream().collect(Collectors.groupingBy(po -> {
			List<Column> parameterList = new ArrayList<>();
			builder.setLength(0);
			builder.append("update")
					.append(MybatisSqlBuilder.BLANK)
					.append(tableName)
					.append(MybatisSqlBuilder.BLANK)
					.append("set").append(MybatisSqlBuilder.BLANK);
			Filters.UpdateNonBlankFilter updateNonBlankFilter = new Filters.UpdateNonBlankFilter(po);
			Predicate<Column> filter = (updateNonBlankFilter.and(Filters.UPDATABLE_FILTER)).or(Filters.ALWAYS_UPDATE_FILTER);
			String set = table.getColumns().stream().filter(filter).map(column -> {
				StringBuilder setBuilder = new StringBuilder();
				if (column.isVersioned()) {
					setBuilder.append(column.getSqlName()).append(MybatisSqlBuilder.BLANK).append("=").append(MybatisSqlBuilder.BLANK)
							.append(column.getSqlName()).append(" + 1").append(MybatisSqlBuilder.BLANK);
				} else {
					setBuilder.append(MybatisSqlBuilder.BLANK);
					setBuilder.append(column.getSqlName()).append("=").append(" ?").append(MybatisSqlBuilder.BLANK);
					parameterList.add(column);
				}
				return setBuilder.toString();
			}).collect(Collectors.joining(","));
			builder.append(set);
			builder.append(MybatisSqlBuilder.BLANK).append("where").append(MybatisSqlBuilder.BLANK);
			builder.append(
					table.getColumns().stream().filter(Column::isPk).map(column -> {
						parameterList.add(column);
						return column.getSqlName() + " = ? ";
					}).collect(Collectors.joining("and"))
			);
			return new SqlAndParameter(builder.toString(), parameterList);
		}));
		int rows = 0;
		for (Map.Entry<SqlAndParameter, List<Object>> entry : mappedStatement.entrySet()) {
			SqlAndParameter key = entry.getKey();
			String sql = key.getSql();
			List<Column> parameterList = key.getColumns();
			List<Object> collectedPoList = entry.getValue();
			try (PreparedStatement ps = conn.prepareStatement(sql)) {
				for (Object po : collectedPoList) {
					for (int i = 0; i < parameterList.size(); i++) {
						Column column = parameterList.get(i);
						Object fieldValue = ReflectionUtils.getFieldValue(po, column.getJavaName());
						TypeHandler typeHandler = thr.getTypeHandler(column.getJavaType());
						try {
							typeHandler.setParameter(ps, i + 1, fieldValue, JdbcType.forCode(column.getSqlType().getVendorTypeNumber()));
						} catch (SQLException sqlException) {
							logger.error("error set parameter(name=" + column.getJavaName() + ",value=" + fieldValue + ",caused by:" + sqlException.getSQLState(), sqlException);
						}
					}
					ps.addBatch();
				}
				int[] ints = ps.executeBatch();
				rows = rows + Arrays.stream(ints).sum();
			}
		}
		return rows;
	}

	private int doOneTableBatchUpdateNonNull(TypeHandlerRegistry thr, Executor executor, List<Object> poList, Table table, String tableName) throws SQLException {
		Connection conn = executor.getTransaction().getConnection();
		final StringBuilder builder = new StringBuilder();
		Map<SqlAndParameter, List<Object>> mappedStatement = poList.stream().collect(Collectors.groupingBy(po -> {
			List<Column> parameterList = new ArrayList<>();
			builder.setLength(0);
			builder.append("update")
					.append(MybatisSqlBuilder.BLANK)
					.append(tableName)
					.append(MybatisSqlBuilder.BLANK)
					.append("set").append(MybatisSqlBuilder.BLANK);
			Filters.UpdateNonNullFilter nonNullFilter = new Filters.UpdateNonNullFilter(po);
			Predicate<Column> filter = (nonNullFilter.and(Filters.UPDATABLE_FILTER)).or(Filters.ALWAYS_UPDATE_FILTER);
			String set = table.getColumns().stream().filter(filter).map(column -> {
				StringBuilder setBuilder = new StringBuilder();
				if (column.isVersioned()) {
					setBuilder.append(column.getSqlName()).append(MybatisSqlBuilder.BLANK).append("=").append(MybatisSqlBuilder.BLANK)
							.append(column.getSqlName()).append(" + 1").append(MybatisSqlBuilder.BLANK);
				} else {
					setBuilder.append(MybatisSqlBuilder.BLANK);
					setBuilder.append(column.getSqlName()).append("=").append(" ?").append(MybatisSqlBuilder.BLANK);
					parameterList.add(column);
				}
				return setBuilder.toString();
			}).collect(Collectors.joining(","));
			builder.append(set);
			builder.append(MybatisSqlBuilder.BLANK).append("where").append(MybatisSqlBuilder.BLANK);
			builder.append(
					table.getColumns().stream().filter(Column::isPk).map(column -> {
						parameterList.add(column);
						return column.getSqlName() + " = ? ";
					}).collect(Collectors.joining("and"))
			);
			return new SqlAndParameter(builder.toString(), parameterList);
		}));
		int rows = 0;
		for (Map.Entry<SqlAndParameter, List<Object>> entry : mappedStatement.entrySet()) {
			SqlAndParameter key = entry.getKey();
			String sql = key.getSql();
			List<Column> parameterList = key.getColumns();
			List<Object> collectedPoList = entry.getValue();
			try (PreparedStatement ps = conn.prepareStatement(sql)) {
				for (Object po : collectedPoList) {
					for (int i = 0; i < parameterList.size(); i++) {
						Column column = parameterList.get(i);
						Object fieldValue = ReflectionUtils.getFieldValue(po, column.getJavaName());
						TypeHandler typeHandler = thr.getTypeHandler(column.getJavaType());
						try {
							typeHandler.setParameter(ps, i + 1, fieldValue, JdbcType.forCode(column.getSqlType().getVendorTypeNumber()));
						} catch (SQLException sqlException) {
							logger.error("error set parameter(name=" + column.getJavaName() + ",value=" + fieldValue + ",caused by:" + sqlException.getSQLState(), sqlException);
						}
					}
					ps.addBatch();
				}
				int[] ints = ps.executeBatch();
				rows = rows + Arrays.stream(ints).sum();
			}
		}
		return rows;
	}


	private int doOneTableUpdate(TypeHandlerRegistry thr, Executor executor, List<Object> poList, Table table, String tableName, Predicate<Column> predicate) throws SQLException {
		List<List<Object>> batches = sliceBatch(poList, batchSize);
		Connection conn = executor.getTransaction().getConnection();
		int rows = 0;
		QueryBuilder queryBuilder = new QueryBuilder();
		queryBuilder.update(tableName);
		List<Column> updateColumns = table.getColumns().stream().filter(predicate.or(Filters.ALWAYS_UPDATE_FILTER)).collect(Collectors.toList());
		updateColumns.forEach(column -> {
			if (column.isVersioned()) {
				queryBuilder.set(column.getSqlName() + " = " + column.getSqlName() + " + 1 ");
			} else {
				queryBuilder.set(column.getSqlName() + " = ?");
			}
		});
		Column idColumn = table.getColumns().stream().filter(Column::isPk).findFirst().get();
		queryBuilder.where(idColumn.getSqlName() + " =  ?");
		Optional<Column> isDeletedColumn = table.getColumns().stream().filter(Column::isDeleted).findAny();
		isDeletedColumn.ifPresent(column -> {
			queryBuilder.where("and " + column.getSqlName() + " = ?");
		});
		Optional<Column> tenantIdColumn = table.getColumns().stream().filter(Column::isTenantId).findAny();
		tenantIdColumn.ifPresent(column -> {
			queryBuilder.where("and " + column.getSqlName() + " = ?");
		});
		AtomicInteger i = new AtomicInteger(0);
		for (List<?> batch : batches) {
			try (PreparedStatement ps = conn.prepareStatement(queryBuilder.toString())) {
				for (Object po : batch) {
					i.set(1);
					updateColumns.forEach(column -> {
						//version column needn't set parameter
						if (column.isVersioned()) {
							return;
						}
						TypeHandler typeHandler = thr.getTypeHandler(column.getJavaType());
						Object value = ReflectionUtils.getFieldValue(po, column.getJavaName());
						try {
							typeHandler.setParameter(ps, i.getAndIncrement(), value, JdbcType.forCode(column.getSqlType().getVendorTypeNumber()));
						} catch (SQLException sqlException) {
							logger.error("error set parameter(name=" + column.getJavaName() + ",value=" + value + ",caused by:" + sqlException.getSQLState(), sqlException);
						}
					});
					Object value = ReflectionUtils.getFieldValue(po, idColumn.getJavaName());
					if (value == null) {
						throw new BatchOperationException("pk property:" + idColumn.getJavaName() + " of class:" + table.getJavaName() + " is null when update");
					}
					try {
						TypeHandler typeHandler = thr.getTypeHandler(idColumn.getJavaType());
						typeHandler.setParameter(ps, i.getAndIncrement(), value, JdbcType.forCode(idColumn.getSqlType().getVendorTypeNumber()));
//						ps.setObject(i.getAndIncrement(), value, idColumn.getSqlType());

					} catch (SQLException sqlException) {
						logger.error("error set parameter(name=" + idColumn.getJavaName() + ",value=" + value + ",caused by:" + sqlException.getSQLState(), sqlException);
					}
					isDeletedColumn.ifPresent(column -> {
						try {
							Class<?> javaType = column.getJavaType();
							if (javaType.getName().equals(Integer.class.getName()) || javaType.getName().equals(int.class.getName())) {
								ps.setInt(i.getAndIncrement(), 0);
							} else if (javaType.getName().equals(Byte.class.getName()) || javaType.getName().equals(byte.class.getName())) {
								ps.setByte(i.getAndIncrement(), (byte) 0);
							} else if (javaType.getName().equals(Short.class.getName()) || javaType.getName().equals(short.class.getName())) {
								ps.setShort(i.getAndIncrement(), (short) 0);
							}
						} catch (SQLException sqlException) {
							logger.error("error set parameter(name=" + column.getJavaName() + ",value=" + 0 + ",caused by:" + sqlException.getSQLState(), sqlException);
						}
					});
					tenantIdColumn.ifPresent(column -> {
						String tenantId = SystemContextHolder.getTenantId();
						try {
							ps.setString(i.getAndIncrement(), tenantId);
						} catch (SQLException sqlException) {
							logger.error("error set parameter(name=" + column.getJavaName() + ",value=" + tenantId + ",caused by:" + sqlException.getSQLState(), sqlException);
						}
					});
					ps.addBatch();
				}
				int[] ints = ps.executeBatch();
				rows = rows + Arrays.stream(ints).sum();
			}
		}
		return rows;
	}

	@Override
	protected boolean shouldApply(Invocation invocation, Triple<BatchType, List<Object>, Table> context) {
		BatchType batchType = context.getLeft();
		Table right = context.getRight();
		switch (batchType) {
			case BatchInsert:
			case BatchUpdateNonBlank:
			case BatchUpdateNonNull:
			case BatchUpdateFixed:
				return true;
			case None:
			default:
				return false;
		}
	}

	@Override
	public String getName() {
		return "SimpleBatchInterceptor";
	}

	@Override
	public void setProperties(Properties properties) {

	}

	private String getShardingValue(List<String> shardingValues) {
		return shardingValues.stream().reduce((r, s) -> r + "|" + s).orElse(null);
	}

	private ShardingManager getShardingManager() {
		return ServiceLocator.getService(ShardingManager.class);
	}

	private static class SqlAndParameter {
		private final String sql;
		private final List<Column> columns;


		private SqlAndParameter(String sql, List<Column> columns) {
			this.sql = sql;
			this.columns = columns;
		}

		public String getSql() {
			return sql;
		}

		public List<Column> getColumns() {
			return columns;
		}

		@Override
		public boolean equals(Object o) {
			if (this == o) {
				return true;
			}
			if (!(o instanceof SqlAndParameter)) {
				return false;
			}
			SqlAndParameter that = (SqlAndParameter) o;
			return Objects.equals(sql, that.sql);
		}

		@Override
		public int hashCode() {
			return Objects.hash(sql);
		}
	}
}
