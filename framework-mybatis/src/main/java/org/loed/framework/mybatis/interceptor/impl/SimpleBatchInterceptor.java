package org.loed.framework.mybatis.interceptor.impl;

import org.apache.commons.collections.CollectionUtils;
import org.apache.commons.lang3.tuple.Triple;
import org.apache.ibatis.executor.Executor;
import org.apache.ibatis.mapping.MappedStatement;
import org.apache.ibatis.plugin.Intercepts;
import org.apache.ibatis.plugin.Invocation;
import org.apache.ibatis.plugin.Signature;
import org.loed.framework.common.ServiceLocator;
import org.loed.framework.common.context.SystemContextHolder;
import org.loed.framework.common.data.DataType;
import org.loed.framework.common.orm.Column;
import org.loed.framework.common.orm.Filters;
import org.loed.framework.common.orm.Table;
import org.loed.framework.common.query.QueryBuilder;
import org.loed.framework.common.util.ReflectionUtils;
import org.loed.framework.mybatis.BatchOperationException;
import org.loed.framework.mybatis.BatchType;
import org.loed.framework.mybatis.sharding.ShardingManager;
import org.loed.framework.mybatis.sharding.table.po.IdMapping;

import javax.persistence.GenerationType;
import java.io.Serializable;
import java.sql.*;
import java.util.*;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.function.Predicate;
import java.util.stream.Collectors;

/***
 * @author wiki
 * todo add metrics
 * todo make type conversion as complete as jdbc
 * @version 1.0.0
 */
@SuppressWarnings("Duplicates")
@Intercepts(
		{
				@Signature(type = Executor.class, method = "update", args = {MappedStatement.class, Object.class}),
		}
)
public class SimpleBatchInterceptor extends BaseBatchInterceptor {

	public SimpleBatchInterceptor() {
	}

	public SimpleBatchInterceptor(int batchSize) {
		super(batchSize);
	}

	@Override
	protected int doBatchInsert(Executor executor, List<Object> poList, Table table) throws SQLException {
		Column idColumn = table.getColumns().stream().filter(Column::isPk).findFirst().orElse(null);
		if (idColumn == null) {
			throw new RuntimeException("entity:" + table.getJavaName() + " has no id column");
		}
		if (table.isSharding()) {
			Map<String, List<Object>> groupedMap = new HashMap<>();
			Set<String> shardingValues = new HashSet<>();
			List<Column> shardingColumns = table.getColumns().stream().filter(Column::isShardingColumn).sorted().collect(Collectors.toList());
			if (CollectionUtils.isEmpty(shardingColumns)) {
				throw new RuntimeException("sharding columns is empty");
			}
			for (Object po : poList) {
				List<String> values = new ArrayList<>();
				shardingColumns.forEach(column -> values.add(String.valueOf(ReflectionUtils.getFieldValue(po, column.getJavaName()))));
				String shardingValue = getShardingValue(values);
				shardingValues.add(shardingValue);
				List<Object> list = groupedMap.computeIfAbsent(shardingValue, k -> new ArrayList<>());
				list.add(po);
			}
			Map<String, String> tableNameMap = getShardingManager().getShardingTableNameByValues(table, shardingValues);

			Map<String, List<String>> reversedMap = new HashMap<>();
			tableNameMap.forEach((k, v) -> {
				reversedMap.computeIfAbsent(v, t -> new ArrayList<>()).add(k);
			});

			int total = 0;
			List<IdMapping> idMappings = new ArrayList<>(poList.size());
			GenerationType idGenerationType = table.getIdGenerationType();
			for (Map.Entry<String, List<String>> entry : reversedMap.entrySet()) {
				String tableName = entry.getKey();
				List<String> values = entry.getValue();
				List<Object> oneTableBatchList = new ArrayList<>();
				if (idGenerationType != GenerationType.AUTO) {
					values.forEach(v -> {
						List<Object> list = groupedMap.get(v);
						for (Object po : list) {
							IdMapping idMapping = new IdMapping();
							idMapping.setShardingTableName(tableName);
							idMapping.setTableName(table.getSqlName());
							idMapping.setShardingValue(v);
							idMapping.setShardingKey(shardingColumns.stream().map(Column::getSqlName).collect(Collectors.joining(",")));
							idMapping.setTableId((Serializable) ReflectionUtils.getFieldValue(po, idColumn.getJavaName()));
							idMappings.add(idMapping);
							oneTableBatchList.add(po);
						}
					});
				}
				total += doOneTableBatchInsert(executor, oneTableBatchList, table, tableName);
				//if id is autogenerated id will get after insert
				if (idGenerationType == GenerationType.AUTO) {
					values.forEach(v -> {
						List<Object> list = groupedMap.get(v);
						for (Object po : list) {
							IdMapping idMapping = new IdMapping();
							idMapping.setShardingTableName(tableName);
							idMapping.setTableName(table.getSqlName());
							idMapping.setShardingValue(v);
							idMapping.setShardingKey(shardingColumns.stream().map(Column::getSqlName).collect(Collectors.joining(",")));
							idMapping.setTableId((Serializable) ReflectionUtils.getFieldValue(po, idColumn.getJavaName()));
							idMappings.add(idMapping);
							oneTableBatchList.add(po);
						}
					});
				}
			}
			//保存Id映射
			getShardingManager().saveIdMappings(idMappings.toArray(new IdMapping[0]));
			return total;
		} else {
			return doOneTableBatchInsert(executor, poList, table, table.getSqlName());
		}
	}

	private int doOneTableBatchInsert(Executor executor, List<Object> poList, Table table, String taleName) throws SQLException {
		StringBuilder builder = new StringBuilder(table.getColumns().size() * 20 + 3);
		String sql = buildInsertSql(taleName, table.getColumns(), builder);

		List<List<Object>> batches = sliceBatch(poList, batchSize);
		int rows = 0;
		long start = System.currentTimeMillis();
		if (logger.isDebugEnabled()) {
			logger.debug("batch insert log: {} start ", sql);
		}
		Connection conn = executor.getTransaction().getConnection();
		for (List<Object> batch : batches) {
			rows = rows + doOneBatchInsert(conn, batch, table, sql);
		}
		if (logger.isDebugEnabled()) {
			logger.debug("batch insert done log, time :{}, rows {}, sql {}, ", System.currentTimeMillis() - start, rows, sql);
		}
		return rows;
	}

	@Override
	protected int doBatchUpdateNonBlank(Executor executor, List<Object> poList, Table table, Predicate<Column> predicate) throws SQLException {
		Column idColumn = table.getColumns().stream().filter(Column::isPk).findFirst().orElse(null);
		if (idColumn == null) {
			throw new RuntimeException("entity class : " + table.getJavaName() + " has no id column");
		}
		if (table.isSharding()) {
			Map<Serializable, Object> objectMap = new HashMap<>();
			Set<Serializable> idSet = new HashSet<>();
			for (Object po : poList) {
				Serializable id = (Serializable) ReflectionUtils.getFieldValue(po, idColumn.getJavaName());
				idSet.add(id);
				objectMap.put(id, po);
			}
			Map<Serializable, String> tableNameMap = getShardingManager().getShardingTableNameByIds(table, idSet);
			if (tableNameMap == null || tableNameMap.isEmpty()) {
				throw new RuntimeException("invalid update list,because it's id hasn't sharding");
			}
			Map<String, List<Serializable>> reversedMap = new HashMap<>();
			tableNameMap.forEach((k, v) -> {
				reversedMap.computeIfAbsent(v, t -> new ArrayList<>()).add(k);
			});
			int total = 0;
			for (Map.Entry<String, List<Serializable>> entry : reversedMap.entrySet()) {
				String tableName = entry.getKey();
				List<Serializable> values = entry.getValue();
				List<Object> oneTableBatchList = values.stream().map(objectMap::get).collect(Collectors.toList());
				total += doOneTableBatchUpdateNonBlank(executor, oneTableBatchList, table, tableName, predicate);
			}
			return total;
		} else {
			return doOneTableBatchUpdateNonBlank(executor, poList, table, table.getSqlName(), predicate);
		}
	}

	@Override
	protected int doBatchUpdateNonNull(Executor executor, List<Object> poList, Table table, Predicate<Column> predicate) throws SQLException {
		Column idColumn = table.getColumns().stream().filter(Column::isPk).findFirst().orElse(null);
		if (idColumn == null) {
			throw new RuntimeException("entity class : " + table.getJavaName() + " has no id column");
		}
		if (table.isSharding()) {
			Map<Serializable, Object> objectMap = new HashMap<>();
			Set<Serializable> idSet = new HashSet<>();
			for (Object po : poList) {
				Serializable id = (Serializable) ReflectionUtils.getFieldValue(po, idColumn.getJavaName());
				idSet.add(id);
				objectMap.put(id, po);
			}
			Map<Serializable, String> tableNameMap = getShardingManager().getShardingTableNameByIds(table, idSet);
			if (tableNameMap == null || tableNameMap.isEmpty()) {
				throw new RuntimeException("invalid update list,because it's id hasn't sharding");
			}
			Map<String, List<Serializable>> reversedMap = new HashMap<>();
			tableNameMap.forEach((k, v) -> {
				reversedMap.computeIfAbsent(v, t -> new ArrayList<>()).add(k);
			});
			int total = 0;
			for (Map.Entry<String, List<Serializable>> entry : reversedMap.entrySet()) {
				String tableName = entry.getKey();
				List<Serializable> values = entry.getValue();
				List<Object> oneTableBatchList = values.stream().map(objectMap::get).collect(Collectors.toList());
				total += doOneTableBatchUpdateNonNull(executor, oneTableBatchList, table, tableName, predicate);
			}
			return total;
		} else {
			return doOneTableBatchUpdateNonNull(executor, poList, table, table.getSqlName(), predicate);
		}
	}

	@Override
	protected int doBatchUpdate(Executor executor, List<Object> poList, Table table, Predicate<Column> predicate) throws SQLException {
		Column idColumn = table.getColumns().stream().filter(Column::isPk).findFirst().orElse(null);
		if (idColumn == null) {
			throw new RuntimeException("entity class : " + table.getJavaName() + " has no id column");
		}
		if (table.isSharding()) {
			Map<Serializable, Object> objectMap = new HashMap<>();
			Set<Serializable> idSet = new HashSet<>();
			for (Object po : poList) {
				Serializable id = (Serializable) ReflectionUtils.getFieldValue(po, idColumn.getJavaName());
				idSet.add(id);
				objectMap.put(id, po);
			}
			Map<Serializable, String> tableNameMap = getShardingManager().getShardingTableNameByIds(table, idSet);
			if (tableNameMap == null || tableNameMap.isEmpty()) {
				throw new RuntimeException("invalid update list,because it's id hasn't sharding");
			}
			Map<String, List<Serializable>> reversedMap = new HashMap<>();
			tableNameMap.forEach((k, v) -> {
				reversedMap.computeIfAbsent(v, t -> new ArrayList<>()).add(k);
			});
			int total = 0;
			for (Map.Entry<String, List<Serializable>> entry : reversedMap.entrySet()) {
				String tableName = entry.getKey();
				List<Serializable> values = entry.getValue();
				List<Object> oneTableBatchList = values.stream().map(objectMap::get).collect(Collectors.toList());
				total += doOneTableUpdate(executor, oneTableBatchList, table, tableName, predicate);
			}
			return total;
		} else {
			return doOneTableUpdate(executor, poList, table, table.getSqlName(), predicate);
		}
	}

	private int doOneTableBatchUpdateNonBlank(Executor executor, List<Object> poList, Table table, String tableName, Predicate<Column> predicate) throws SQLException {
		StringBuilder builder = new StringBuilder((table.getColumns().size() * 20 + 3) * batchSize * 3); //random guess, better than nothing
		List<List<Object>> batches = sliceBatch(poList, batchSize);
		Connection conn = executor.getTransaction().getConnection();
		int rows = 0;
		for (List<Object> batch : batches) {
			try (Statement statement = conn.createStatement()) {
				for (Object object : batch) {
					table.getColumns().stream().filter(Column::isPk).sorted(Comparator.comparing(Column::getJavaName)).forEach(column -> {
						Object fieldValue = ReflectionUtils.getFieldValue(object, column.getJavaName());
						if (fieldValue == null) {
							throw new BatchOperationException("pk property:" + column.getJavaName() + " is null when update");
						}
					});
					Filters.UpdateNonBlankFilter updateNonBlankFilter = new Filters.UpdateNonBlankFilter(object);
					String sql = buildDynamicUpdateSql(builder, tableName, object, table, updateNonBlankFilter.and(predicate));
					if (logger.isDebugEnabled()) {
						logger.debug("simple batch update selective {} ", sql);
					}
					builder.setLength(0);
					statement.addBatch(sql);
				}
				int[] ints = statement.executeBatch();
				rows = rows + Arrays.stream(ints).sum();
			}
		}
		return rows;
	}

	private int doOneTableBatchUpdateNonNull(Executor executor, List<Object> poList, Table table, String tableName, Predicate<Column> predicate) throws SQLException {
		StringBuilder builder = new StringBuilder((table.getColumns().size() * 20 + 3) * batchSize * 3); //random guess, better than nothing
		List<List<Object>> batches = sliceBatch(poList, batchSize);
		Connection conn = executor.getTransaction().getConnection();
		int rows = 0;
		for (List<Object> batch : batches) {
			try (Statement statement = conn.createStatement()) {
				for (Object object : batch) {
					table.getColumns().stream().filter(Column::isPk).sorted(Comparator.comparing(Column::getJavaName)).forEach(column -> {
						Object fieldValue = ReflectionUtils.getFieldValue(object, column.getJavaName());
						if (fieldValue == null) {
							throw new BatchOperationException("pk property:" + column.getJavaName() + " is null when update");
						}
					});
					Filters.UpdateNonNullFilter updateNonNullFilter = new Filters.UpdateNonNullFilter(object);
					String sql = buildDynamicUpdateSql(builder, tableName, object, table, updateNonNullFilter.and(predicate));
					if (logger.isDebugEnabled()) {
						logger.debug("simple batch update selective {} ", sql);
					}
					builder.setLength(0);
					statement.addBatch(sql);
				}
				int[] ints = statement.executeBatch();
				rows = rows + Arrays.stream(ints).sum();
			}
		}
		return rows;
	}


	private int doOneTableUpdate(Executor executor, List<Object> poList, Table table, String tableName, Predicate<Column> predicate) throws SQLException {
		List<List<Object>> batches = sliceBatch(poList, batchSize);
		Connection conn = executor.getTransaction().getConnection();
		int rows = 0;
		QueryBuilder queryBuilder = new QueryBuilder();
		queryBuilder.update(tableName);
		List<Column> updateColumns = table.getColumns().stream().filter(predicate.or(Filters.ALWAYS_UPDATE_FILTER)).collect(Collectors.toList());
		updateColumns.forEach(column -> {
			if (column.isVersioned()) {
				queryBuilder.set(column.getSqlName() + " = " + column.getSqlName() + " + 1 ");
			} else {
				queryBuilder.set(column.getSqlName() + " = ?");
			}
		});
		Column idColumn = table.getColumns().stream().filter(Column::isPk).findFirst().get();
		queryBuilder.where(idColumn.getSqlName() + " =  ?");
		Optional<Column> isDeletedColumn = table.getColumns().stream().filter(Column::isDeleted).findAny();
		isDeletedColumn.ifPresent(column -> {
			queryBuilder.where("and " + column.getSqlName() + " = ?");
		});
		Optional<Column> tenantIdColumn = table.getColumns().stream().filter(Column::isTenantId).findAny();
		tenantIdColumn.ifPresent(column -> {
			queryBuilder.where("and " + column.getSqlName() + " = ?");
		});
		AtomicInteger i = new AtomicInteger(0);
		for (List<?> batch : batches) {
			try (PreparedStatement ps = conn.prepareStatement(queryBuilder.toString())) {
				for (Object po : batch) {
					i.set(1);
					updateColumns.forEach(column -> {
						//version column needn't set parameter
						if (column.isVersioned()) {
							return;
						}
						int dataType = DataType.getDataType(column.getJavaType());
						Object value = ReflectionUtils.getFieldValue(po, column.getJavaName());
						try {
							if ((DataType.DT_Boolean == dataType || DataType.DT_boolean == dataType)
									&& JDBCType.INTEGER.getVendorTypeNumber() == column.getSqlType()) {
								Boolean booleanValue = (Boolean) DataType.toType(value, DataType.DT_Boolean);
								if (booleanValue != null) {
									ps.setObject(i.getAndIncrement(), booleanValue ? 1 : 0, column.getSqlType());
								} else {
									ps.setObject(i.getAndIncrement(), null, column.getSqlType());
								}
							} else {
								ps.setObject(i.getAndIncrement(), value, column.getSqlType());
							}
						} catch (SQLException sqlException) {
							logger.error("error set parameter(name=" + column.getJavaName() + ",value=" + value + ",caused by:" + sqlException.getSQLState(), sqlException);
						}
					});
					Object value = ReflectionUtils.getFieldValue(po, idColumn.getJavaName());
					if (value == null) {
						throw new BatchOperationException("pk property:" + idColumn.getJavaName() + " of class:" + table.getJavaName() + " is null when update");
					}
					try {
						ps.setObject(i.getAndIncrement(), value, idColumn.getSqlType());
					} catch (SQLException sqlException) {
						logger.error("error set parameter(name=" + idColumn.getJavaName() + ",value=" + value + ",caused by:" + sqlException.getSQLState(), sqlException);
					}
					isDeletedColumn.ifPresent(column -> {
						try {
							Class<?> javaType = column.getJavaType();
							if (javaType.getName().equals(Integer.class.getName()) || javaType.getName().equals(int.class.getName())) {
								ps.setInt(i.getAndIncrement(), 0);
							} else if (javaType.getName().equals(Byte.class.getName()) || javaType.getName().equals(byte.class.getName())) {
								ps.setByte(i.getAndIncrement(), (byte) 0);
							} else if (javaType.getName().equals(Short.class.getName()) || javaType.getName().equals(short.class.getName())) {
								ps.setShort(i.getAndIncrement(), (short) 0);
							}
						} catch (SQLException sqlException) {
							logger.error("error set parameter(name=" + column.getJavaName() + ",value=" + 0 + ",caused by:" + sqlException.getSQLState(), sqlException);
						}
					});
					tenantIdColumn.ifPresent(column -> {
						String tenantId = SystemContextHolder.getTenantId();
						try {
							ps.setString(i.getAndIncrement(), tenantId);
						} catch (SQLException sqlException) {
							logger.error("error set parameter(name=" + column.getJavaName() + ",value=" + tenantId + ",caused by:" + sqlException.getSQLState(), sqlException);
						}
					});
					ps.addBatch();
				}
				int[] ints = ps.executeBatch();
				rows = rows + Arrays.stream(ints).sum();
			}
		}
		return rows;
	}

	@Override
	protected boolean shouldApply(Invocation invocation, Triple<BatchType, List<Object>, Table> context) {
		BatchType batchType = context.getLeft();
		Table right = context.getRight();
		switch (batchType) {
			case BatchInsert:
			case BatchUpdateNonBlank:
			case BatchUpdateNonNull:
			case BatchUpdateFixed:
				return true;
			case None:
			default:
				return false;
		}
	}

	@Override
	public String getName() {
		return "SimpleBatchInterceptor";
	}

	@Override
	public void setProperties(Properties properties) {

	}

	private String getShardingValue(List<String> shardingValues) {
		return shardingValues.stream().reduce((r, s) -> r + "|" + s).orElse(null);
	}

	private ShardingManager getShardingManager() {
		return ServiceLocator.getService(ShardingManager.class);
	}
}
